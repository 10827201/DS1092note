### Important Words
> vertex --edge--> vertex : directed <br>
> vertex <--edge--> vertex : undirected <br>
> Adjacency Matrix<br>
> A --edge--> B : [A][B] = 1, [B][A] = 0<br>
> A <--edge--> B : [A][B] = 1, [B][A] = 1<br>
> A <--edge-- B : [A][B] = 0, [B][A] = 1<br>
> A           B : [A][B] = 0, [B][A] = 0<br>
> <br>
> Adjacency List (linkedlist): Graph define Set, so the order of vertex iis not important.<br>
> undirected : List out all elements, and linked all the vertexes that linked to them.<br>
> directed : Use the pointers to define which to linked to the elements. <br>
<br>

- Cycle
  - 不會重覆經過同一個點和同一條邊的路線，頭尾循環。
<img width="500" alt="1-ilearning" src="https://user-images.githubusercontent.com/48556705/121007256-68c21780-c7c4-11eb-8c2f-c0c346cbbc5f.png">
<img width="500" alt="2-ilearning" src="https://user-images.githubusercontent.com/48556705/121007309-77103380-c7c4-11eb-8cda-a48e1226c6aa.png">
<img width="500" alt="3-ilearning" src="https://user-images.githubusercontent.com/48556705/121007292-71b2e900-c7c4-11eb-8583-db7f887c0582.png">

- Directed Acyclic Graph （ DAG ）
  - 有向無環圖 

- Topological Sort
  - 拓墣排序
  - 只會由 a 點指向 b點，b 點不會指向 a 點 // 例如：「有向」且「無環」圖。
  - 一張圖可以有很多種拓墣排序，只要不違背圖上每一條邊的先後順緒，怎麼連都可以。
  - 圖上 **不可以** 有環（ cycle ）!
  - 圖解：
<img width="500" alt="4-ilearning" src="https://user-images.githubusercontent.com/48556705/121008483-a2475280-c7c5-11eb-8bf5-1865d0982508.png">
------------------------------------------------------------------------> <br>
 <br>
此圖為有向無環圖 <br>
 <br>
從上可見： <br>
 <br>
由 1 走到可以走到 4，但 4 不能走向 1 <br>
由 2 走到可以走到 4，但 4 不能走向 2 <br>
由 3 走到可以走到 4，但 4 不能走向 3 <br>
＊3 / 4 個 vertex，都同一指向 vertex（ vertex4 ），並且無法從 vertex4 往回到 vertex1, 2, 3＊ <br>
 <br>
從上可見一重要重點：當有向圖出現循環(cycle)，就無法獲得拓撲排序 <br>
 <br>
 <br>
排序方法說明：
 <br>
<img width="500" alt="5-ilearning" src="https://user-images.githubusercontent.com/48556705/121008500-a5dad980-c7c5-11eb-868a-7eea43b09dc1.png">
 <br>
用陣列來表示，每個 vertex 儲存的 edge 數量： <br>
 <br>
step 1：初始化歸零 <br>
 <br>
vertex 1：0 <br>
vertex 2：0 <br>
vertex 3：0 <br>
vertex 4：0 <br>
 <br>
step 2：數數量 <br>
 <br>
vertex 1：1 <br>
vertex 2：1 <br>
vertex 3：0 <br>
vertex 4：3 <br>
<br>
step 3：刪除 edge 數為 0 的 vertex <br>
 <br>
vertex 1：1 <br>
vertex 2：2 <br>
vertex x：x <br>
vertex 4：3 <br>
<br>
<br>
<img width="500" alt="6-ilearning" src="https://user-images.githubusercontent.com/48556705/121008508-a8d5ca00-c7c5-11eb-9e00-d30dee332386.png">
<br>
step 4：重新計算當前 vertex 的 edge <br>
 <br>
vertex 1：1 <br>
vertex 2：0 <br>
vertex x：x <br>
vertex 4：2 <br>
 <br>
step 5：刪除 edge 數為 0 的 vertex <br>
 <br>
vertex 1：1 <br>
vertex x：x <br>
vertex x：x <br>
vertex 4：2 <br>
 <br>
變成下圖
<img width="500" alt="7-ilearning" src="https://user-images.githubusercontent.com/48556705/121008517-aa9f8d80-c7c5-11eb-8697-c25efec4275e.png">
 <br>
step 6：重新計算當前 vertex 的 edge <br>
 <br>
vertex 1：0 <br>
vertex x：x <br>
vertex x：x <br>
vertex 4：1 <br>
 <br>

step 7：刪除 edge 數為 0 的 vertex <br>
 <br>
vertex x：x <br>
vertex x：x <br>
vertex x：x <br>
vertex 4：1 <br>
 <br>

變成下圖 <br>
<img width="500" alt="8-ilearning" src="https://user-images.githubusercontent.com/48556705/121008525-ad01e780-c7c5-11eb-86ce-31b323dea20a.png">
 <br>
 step 8：重新計算當前 vertex 的 edge <br>
 <br>
vertex x：x <br>
vertex x：x <br>
vertex x：x <br>
vertex 4：0 <br>
 <br>

最後變成下圖 <br>
<img width="500" alt="9-ilearning" src="https://user-images.githubusercontent.com/48556705/121008540-af644180-c7c5-11eb-9768-191c5818020c.png">
 <br>
 結論 <br>
 <br>
此次範例的拓撲排序為：vertex 3 --> vertex 2 --> vertex 1 --> vertex 4 <br>
 <br>
因為拓撲排序的排序方式為「把 edge 為 0 的 vertex 先刪除」，所以不能是循環cycle，否則將會無法刪除 vertex <br>
 <br>
 
 - Spanning Tree
  - 「生成樹」
  - 從一張圖取出一棵樹，包含圖上所有點。
  - Minimum Spanning Tree
    - 權重最小的生成樹。

 - Shortest Paths
  - 「最短路徑」是由起點到終點、權重最小的路徑。
  - 可能有很多條。
  - 起點到終點不通、不存在路徑的時候，就沒有最短路徑。

- Critical Path Analysis（ CPM ）
  - 關鍵路徑法
  - 為了表示 performance 而存在的 。

- Maximum Flow Problem
  -  最大流
  -  在一張圖中，以及給定一個源點與一個匯點，所有可能的 Flow 當中，流量最大者就是 Maximum Flow。
  -  可能會有很多個。

- B-Tree
  - Balance Tree
  - 平衡的多路搜尋樹
  - 根節點要就是葉子, 不然至少有兩個子節點。
  - 每個節點最多含有m個節點(m ≥ 2)。
  - 所有的葉節點都出現在同一層上。
  
- External Sort 
  - 外部排序
  - 分次載入部份的資料到記憶體，用內部排序演算法排序後再回存或合併結果。

